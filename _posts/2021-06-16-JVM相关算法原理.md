---
title: "JVM 底层原理"
last_modified_at: 2021-06-16T13:20:02-05:00
categories:
  - Blog
tags:
  -  JVM
# link: https://foresx.github.io/blog
header:
  overlay_image: /assets/images/banner.jpg
  overlay_filter: 0.5

---

## JDK 1.6, 1.7, 1.8 对比

JDK 1.6: 有永久代,静态变量存放在永久代上
JDK 1.7: 有永久代,但已经把字符串常量池、静态变量,存放在堆上。逐渐的减少永久代的使用
JDK 1.8: 无永久代,运行时常量池、类常量池,都保存在元数据区,也就是常说的元空间。但字符串常量池仍然存放在堆上

[常量池介绍](http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/)

### 字符串常量池(string pool), 存放"abc"这种的引用. 并不是实例本身

1. 全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的）
2. 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。

### class文件常量池（class constant pool）

class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。

**字面量就是我们所说的常量概念**，**如文本字符串、被声明为final的常量值等。**
> 符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）

一般包括下面三类常量：

1. 类和接口的全限定名
2. 字段的名称和描述符
3. 方法的名称和描述符

### 运行时常量池（runtime constant pool）

当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池，那么运行时常量池又是什么时候产生的呢？

jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。

string.intern() 有类似的功能,替换符号引用为直接引用

### 总结

1. 全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。
2. class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。
3. 运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。

## 根节点选举

所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的,因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰

为了实现准确式 GC, 所以必须要对 GC ROOTS 的枚举保证正确, 通过在 VM 中的 **OopMap 保证**

### GC ROOTS 有哪些?

**所谓“GC roots”，或者说tracing GC的“根集合”，就是一组必须活跃的引用。**
例如说，这些引用可能包括：

1. 所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
2. VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。
3. JNI handles，包括global handles和local handles
4. （看情况）所有当前被加载的Java类
5. （看情况）Java类的引用类型静态变量
6. （看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）
7. （看情况）String常量池（StringTable）里的引用注意，是一组必须活跃的引用，不是对象。

## 为什么要做分代设计? 理论依据是什么?

1. 弱分代假说(Weak Generational Hypothesis):绝大多数对象都是朝生夕灭的
2. 强分代假说(Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象就越难以消亡
3. 跨代引用假说(Intergenerational Reference Hypothesis):跨代引用相对于同代引用来说仅占极少数

### 安全点, 安全区域

实际上HotSpot也的确没有为每条指令都生成OopMap,前面已经提到,只是在“特定的位置”记录了这些信息,这些位置被称为**安全点(Safe point)**

安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的.

> 因为每条指令执行的时间都非常短暂,程序不太可能因为指令流长度太长这样的原因而长时间执行,**“长时间执行”的最明显特征就是指令序列的复用,例如方法调用、循环跳转、异常跳转等都属于指令序列复用,所以只有具有这些功能的指令才会产生安全点**

#### 如何让所有线程能够跑在最近的安全点上停下?

抢先式中断 and 主动式中断

抢先式中断不需要线程的执行代码主动去配合,在垃圾收集发生时,系统**首先把所有用户线程全部中断**,如果发现有用户线程中断的地方**不在安全点上**,就**恢复这条线程执行,让它一会再重新中断,直到跑到安全点上** (先停止,再判断,重新跑到安全点) 几乎没有虚拟机采用这种方案

**主动式中断**: 当垃圾收集需要中断线程的时候,不直接对线程操作,仅仅简单地**设置一个标志位**,各个**线程执行过程时会不停地主动去轮询这个标志**,一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。

> 由于轮询操作在代码中会频繁出现,这要求它必须足够高效。HotSpot使用内存保护陷阱的方式, 把轮询操作精简至只有一条汇编指令的程度。下面代码清单3-4中的test指令就是HotSpot生成的轮询指令,当需要暂停用户线程时,虚拟机把0x160100的内存页设置为不可读,那线程执行到test指令时就会产生一个自陷异常信号,然后在预先注册的异常处理器中挂起线程实现等待,这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了

### 安全区域

安全点机制保证了程序执行时,在不太长的时间内就会遇到可进入垃圾收集过程的安全点

安全点存在的问题在于: 无法保证没有被分配到处理器时间的线程无法走到安全的地方去中断自己.

**安全区域**是指能够确保在某一段代码片段之中,引用关系不会发生变化,因此,在这个区域中任意地方开始垃圾收集都是安全的, 可以看做是被扩展拉伸的安全点

> 所以当线程进入安全区域的时候, 会标识自己进入了安全区域. 当vm 发起 gc 的时候就不需要管这些已经在 safe region 的线程了
> 当线程需要离开的时候,需要检查 vm 是否完成了 gc roots 的枚举, 如果完成了就当没事. 如果没有的话就需要一致等待,直到收到可以离开 safe region 的信号为止

相当于有一个检查区域, 你收到通知才能离开. 通知的前提就是完成了 gc roots 的枚举

## 对象跨代引用的问题

跨代引用会导致在发生 minor gc 的时候需要去检查老年代的一些对象
为解决对象跨代引用所带来的问题,垃圾收集器在新生代中建立了名为记忆集(Remembered Set)的数据结构,用以**避免把整个老年代加进GC Roots扫描范围**, 通过记忆集, 只记录跨代引用的对象,只需要扫描这些存在跨代引用的对象

收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了,并不需要了解这些跨代指针的全部细节

### 三种记录的精度

- 字长精度:每个记录精确到一个机器字长(就是处理器的寻址位数,如常见的32位或64位,这个精度决定了机器访问物理内存地址的指针长度),该字包含跨代指针
- 对象精度:每个记录精确到一个对象,该对象里有字段含有跨代指针。
- 卡精度:每个记录精确到一块内存区域,该区域内有对象含有跨代指针(这种方式就叫做卡表)

一个卡页的内存中通常包含不止一个对象,**只要卡页内有一个(或更多)对象的字段存在着跨代指针,那就将对应卡表的数组元素的值标识为1,称为这个元素变脏(Dirty),没有则标识为0**。在垃圾收集发生时,只要筛选出卡表中变脏的元素,就能轻易得出哪些卡页内存块中包含跨代指针,把它们加入GC Roots中一并扫描

### 如何维护卡表?

在HotSpot虚拟机里是通过写屏障(Write Barrier)技术维护卡表状态的, 相当于一个 aop, 有写前屏障和写后屏障, 但是g1 出来以前都是用的写后屏障

```c
void oop field store(oop* field, oop_new_value) {
    //引用字段赋值操作大
    *fie1d = new_value;
    //写后屏障,在这里完成卡表状态更新
    post_write_barrier(field, new_value)
}  
```

在JDK 7之后,HotSpot虚拟机增加了一个新的参数-XX:+UseCondCardMark,用来决定是否开启卡表更新的条件判断(如果已经是脏的了,那就不用写了)。开启会增加一次额外判断的开销,但能够避免伪共享问题,两者各有性能损耗,是否打开要根据应用实际运行情况来进行测试权衡

## 可达性分析

### 三色标记法

一种帮助理解可达性分析算法的模型而已

- 白色: **表示对象尚未被垃圾收集器访问过**。显然在可达性分析刚刚开始的阶段,所有的对象都是白色的,若在分析**结束的阶段,仍然是白色的对象,即代表不可达**(还没扫到,或者是扫到了但是不可达)
- 黑色:**表示对象已经被垃圾收集器访问过,且这个对象的所有引用都已经扫描过**。黑色的对象代表已经扫描过,它是安全存活的,**如果有其他对象引用指向了黑色对象,无须重新扫描一遍。黑色对象不可能直接(不经过灰色对象)指向某个白色对象**。(引用扫描完毕并且是存活的)
- 灰色:**表示对象已经被垃圾收集器访问过,但这个对象上至少存在一个引用还没有被扫描过** (没扫描完全引用)

### 漏报的情况什么时候会发生?

**因为在gc 的过程中, gc 线程和用户线程是并发的, 所以会导致对象的可达性发生变化.**

**漏报**: 指的是原来应该被标记成黑色的对象,因为一些原因没有上色,从而导致回收了不该回收的.
**误报**: 多标记了黑色不影响最后的结果,只会造成少回收对象. 所以只有误漏的这种情况需要注意.

1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用(**新增了黑色到白色的引用**)
2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用(**删除了所有灰色到该白色的引用**)

### 如何解决漏报情况的发生?

破坏两个充分必要条件的一个即可.

1. 增量更新: 黑色对象一旦新插入了指向白色对象的引用之后,它就变回灰色对象了(实际实现上是,会标记被增加了白色对象的引用的黑色对象,从而下次回头重新扫描一次), **解决新增连接的问题**
2. 原始快照: 无论引用关系删除与否,都会按照刚刚开始扫描那一刻的对象图快照来进行搜索(记录下被删除的灰到白的引用,并发后重新扫描一次), **解决连接断开的问题**

CMS 中采用增量更新来做并发标记的, G1 采用的是原始快照来实现的

## 垃圾回收算法

### 标记-清除(mark-sweep)

- 标记无引用的死亡对象所占据的空闲内存,并记录到空闲列表中(free list)
- 当需要创建新对象时,内存管理模块会从 free list 中寻找空闲内存,分配给新建的对象

优点是高效,但是缺点是会带来内存的碎片化

CMS 中有使用, 因为可以带来更短的暂停时间

### 标记-复制(mark-copy)

- 把内存区域分成两份,分别用两个指针 from 和 to 维护,并且只使用 from 指针指向的内存区域分配内存
- 当发生垃圾回收时,则把存活对象复制到 to 指针指向的内存区域,并交换 from 与 to 指针

优点是解决了内存的碎片化问题, 缺点是带来了一半内存的浪费

常在新生代使用这种算法. S0, S1

### 标记-压缩/整理(mark-compact)

标记的过程和标记清除算法一样,但在后续对象清理步骤中,先把存活对象都向内存空间一端移动,然后在清理掉其他内存空间

优点是解决了碎片化的问题同时内存也没有浪费,但是缺点也很明显移动对象需要更多的时间,性能开销不小

G1 收集器采用
