---
title: "树的学习"
last_modified_at: 2021-01-31T16:05:02-05:00
categories:
  - Blog
tags:
  - 数据结构
  - tree
# link: https://foresx.github.io/blog
header:
  overlay_image: /assets/images/banner.jpeg
  overlay_filter: 0.5

---

### 树

树是一个非线性结构.

#### 概念

1. 什么是节点的度? 节点的分叉(子节点)
2. 什么是树的度? (节点的度 max)
3. 分支节点 度>0
4. 叶子节点 度=0
5. 路径 i->j
6. 路劲的长度 i->j 的节点数-1
7. 子节点
8. 父节点
9. 根节点
10. 兄弟节点, 同父的节点
11. 节点的层次 从第一层开始算
12. 树的高度(从下往上)
13. 树的深度(从上往下)
14. 有序树 按序从左到右
15. 无序树

#### 树的性质

1. 树的节点树为所有节点度数加1（加根节点）。
2. 度为m的树中第i层最多有m^(i-1)个节点。
3. 高度为h的m次树至多(m^h-1)/(m-1)个节点。
4. 具有n个节点的m次树的最小高度为logm( n(m-1) + 1 )向上取整。
5. 不存在环
6. 节点只有一个父节点(除了根节点)

#### 二叉树

二叉树的遍历方式: 前序中序后序遍历(以根节点的位置来决定,先左后右), 保证了每一个只被遍历一次

由二叉树又演变出了二叉查找树.方便排序

##### 二叉查找树

中序遍历就可以找到有序列表了.

左>根>右

时间复杂度最糟糕是 O(n),最快是 O(log n)

所以根据这个又演变除了接下来的树.
因为删除插入的时候没有对树进行维护,导致树最差会变成一个单链表.

##### AVL 树(平衡二叉树,平衡二叉查找树)

名字来源于两个发明者(苏联数学家哦!).
平衡因子的概念为: 节点左右子树的高度差

只有所有结点都符合"平衡因子的绝对值都不超过1"这一条件的二叉树， 才是平衡二叉树；
如果有一个结点不符合条件， 那么这颗二叉树就不是平衡二叉树。

在存在删除或者插入的情况下,导致高度差大于 1 的情况下,需要对其进行平衡.

所以由其尽量保持了层数,那么其查找的时间复杂度可以稳定在 O(log n)

适合在对算法时间比较敏感的应用上.

###### 插入时失衡与调整

最小失衡子树：在**新插入的结点向上查找**，以第一个平衡因子的绝对值超过1的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的，而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树.(为什么是最小呢?因为之前是平衡的,所以插入导致的不平衡存在一个向上的扩展性,即最小失衡一定存在.还可能导致更上层的节点失衡)

插入的四种情况:
L 表示左子树高,R表示右子树高,E 表示等高(不会出现 LE,RE 的情况,如果出现了说明之前已经不平衡了.)

- LL失衡-右旋: zig (顺时针旋转)
- RR失衡-左旋: zag (逆时针旋转)
- LR失衡-先左旋再右旋: zig-zag
- RL失衡-先右旋再左旋: zag-zig

后面两种情况需要考虑到最小平衡子树的较高子树的根节点.所以我们出现了 4 种组合情况.

方法: 寻找最小不平衡树->寻找所属的不平衡类别->根据4种类别进行固定化程序的操作

###### 删除时的平衡与调整

删除时,有可能会进行多次平衡才能达到平衡状态.主要也是分为两种情况, 失去平衡,调整树,并更新节点高度.未失去平衡,更新高度.

##### 红黑树

Java 中,hashmap 就是数组加链表. 当链表长度大于 8 的时候,会自动转换为红黑树,增加查询性能. 当树的节点数被降低为 6 的时候,又会变成链表.

红黑树的设计主要在于他是一个最短路径一定大于最长路径的二分之一的图.相比 AVL 平衡树牺牲了一定的平衡性,换取的是减少重新平衡带来的损耗.

红黑树主要是通过: recolor 和 rotation 来保证树的稳定.

应用场景上: java 的 hashmap. C 语言的 stl 库等.

> todo 后续补上详细的算法以及处理方式

##### B 树(平衡多路查找树)

相比 avl 树,他是一个所有节点的平衡因子均等 0 的多路查找树.

- B树是所有节点的平衡因子均等于0的多路查找树（AVL树是平衡因子不大于 1 的二路查找树
- B 树节点可以保存多个数据，使得 B 树可以不用像 AVL 树那样为了保持平衡频繁的旋转节点
- B树的多路的特性，降低了树的高度，所以B树相比于平衡二叉树显得矮胖很多
- B树非常适合保存在磁盘中的数据读取，因为每次读取都会有一次磁盘IO，高度降低减少了磁盘IO的次数。

B树常用于实现数据库索引，典型的实现，MongoDB索引用B树实现，MySQL的Innodb 存储引擎用B+树存放索引。
B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;

###### B+ 树

B+树是对B树的改进，数据都放在叶子节点，非叶子节点只存数据索引

1. 非叶子结点数据节点存储更多的值.树的层级去更加少了.
2. 查找速度更加稳定,因为每次查找的次数都相同.
3. 天然具备排序功能,b+树的叶子节点构成了一个有序列表,查询数据更方便,数据紧密型很高.缓存更容易命中.
4. 全节点遍历更加快,只需要遍历叶子节点即可.减少了一层遍历

比 B 树慢的情况在于,假如数据离根节点近,那 b 树要快.

###### B* 树

相比 B+ 树增强了兄弟节点的转移.

#### 树的总结

##### 相同思想和策略

采用二分法和数据平衡策略来提升查找数据的速度

##### 不同方式的磁盘空间利用

不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的