---
title: "垃圾收集器"
last_modified_at: 2021-01-10T17:20:02-05:00
categories:
  - Blog
tags:
  - JVM
# link: https://foresx.github.io/blog
header:
  overlay_image: /assets/images/banner.jpg
  overlay_filter: 0.5

---

## 新生代收集器

### Serial 收集器(串行收集器)

新生代采用标记复制算法, 老年代采用标记压缩算法

minor gc, major gc 都会 stw

内存占用小, 适合简单高效的单核机器,client 模式下的默认垃圾收集器(C/S 架构)

### ParNew 收集器

ParNew收集器实质上是**Serial收集器的多线程并行版本**,除了同时使用多条线程进行垃圾收集之外,其余的行为包括Serial收集器可用的所有控制参数

和 CMS(老年代垃圾回收器)搭配使用, CMS 无法和 Parallel Scavenge 一起使用

补充一下并行和并发的区别:
**并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）cpu执行，如果可以就说明是并行，而并发是多个线程被（一个）cpu 轮流切换着执行**

> 并行(Parallel): 并行描述的是多条垃圾收集器线程之间的关系,说明**同一时间有多条这样的线程在协同工作,通常默认此时用户线程是处于等待状态**
> 并发(Concurrent): 描述的是垃圾收集器线程与用户线程之间的关系,说明**同一时间垃圾收集器线程与用户线程都在运行**。由于用户线程并未被冻结,所以程序仍然能响应服务请求,但由于垃圾收集器线程占用了一部分系统资源,此时应用程序的处理的吞吐量将受到一定影响

### Parallel Scavenge收集器

也是基于标记-复制算法实现的收集器, 但是关注的是**达到可控制的吞吐量**

吞吐量= 运行用户代码的时间 / 运行用户代码的时间 + 运行垃圾收集的时间

因为和 CMS 的设计理念完全不同, 所以不能和 CMS 算法一起使用

## 老年代收集器

### Serial Old收集器

标记-压缩算法

性能一般,单线程版本。1.5 之前与 Parallel Scavenge 配合使用
作为 **CMS 的后备预案**

### Parallel Old收集器

标记-压缩算法

GC 多线程并行, 为了替代 Serial Old **与 Parallel Scavenge 配合使用**

### CMS 收集器

默认启动的回收线程数是(处理器核心数量+3)/4, 当cpu 核数较小时, cms 的影响就很大了
CMS(Concurrent Mark Sweep)收集器是一种以获取**最短回收停顿时间为目标**的收集器, 适合 b/s 架构

四个步骤:

1. 初始化标记(initial mark) **stw** gc roots 枚举
2. 并发标记(concurrent mark), 并发的可达性分析
3. 重新标记(remark), 采用增量更新去修正并发标记期间,用户线程导致标记发生变化的对象 **stw**
4. 并发清除(concurrent and sweep)

> i-CMS 增量式并发收集器, CMS 变种. 在并发标记、清理的时候让收集器线程、用户线程交替运行,尽量减少垃圾收集线程的独占资源的时间,这样整个垃圾收集的过程会更长,但对用户程序的影响就会显得较少一些,直观感受是速度变慢的时间更多了,但速度下降幅度就没有那么明显. 但是效果不怎么样,已经 deprecated 了

#### CMS 缺点

无法处理浮动垃圾, 所以有可能出现 concurrent mode 失败,导致 stw 的 full gc 产生

> 浮动垃圾: 在CMS的并发标记和并发清理阶段,用户线程是还在继续运行的,程序在运行自然就还会伴随有新的垃圾对象不断产生,但这一部分垃圾对象是出现在标记过程结束以后,CMS无法在当次收集中处理掉它们,只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”

由于在垃圾收集阶段用户线程还需要持续运行,那就还需要预留足够内存空间提供给用户线程使用,因此**CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集,必须预留一部分空间供并发收集时的程序运作使用**, 默认是 68%, jdk6 以后提升到了 92%, 通过-XX:CMSInitiatingOccupancyFraction可以设置. concurrent mode failure 以后就会采用 serial old 收集器来进行垃圾回收了,但是那样就会导致速度变慢. 所以这个参数设置过高就会导致失败的几率变大,所以需要权衡好.

#### 如何解决 CMS 中导致老年代大量碎片的问题?

-XX:+UseCMS-CompactAtFullCollection, 默认是开启的, 9 以后开始废弃
CMS是一款基于“标记-清除”算法实现的收集器,如果读者对前面这部分介绍还有印象的话,就可能想到这意味着收集结束时会有大量空间碎片产生。空间碎片过多时,将会给大对象分配带来很大麻烦,往往会出现老年代还有很多剩余空间,但就是无法找到足够大的连续空间来分配当前对象,而不得不**提前触发一次Full GC**的情况

触发 full gc 就会导致停顿的时间变得更长, 所以又提供了另外一个参数, **要求CMS收集器在执行过若干次(数量由参数值决定)不整理空间的Full GC之后,下一次进入Full GC前会先进行碎片整理(默认值为0,表示每次进入Full GC时都进行碎片整理)**, 参数为**-XX:CMSFullGCsBeforeCompaction**(此参数从JDK 9开始废弃)

### G1 收集器

开创了收集器**面向局部收集**的设计思路和基**于Region的内存布局**形式

面向堆内存任何部分来组成回收集(Collection Set,一般简称CSet)进行回收,衡量标准不再是它属于哪个分代,而是哪块内存中存放的垃圾数量最多,回收收益最大,这就是G1收集器的**Mixed GC**模式

G1不再坚持固定大小以及固定数量的分代区域划分,而是把连续的Java堆划分为多个大小相等的独立区域(Region),每一个Region都可以根据需要,扮演新生代的Eden空间、Survivor空间,或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理,这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果

#### Humongous Region

Region中还有一类特殊的Humongous区域,专门用来存储大对象。

1. G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象;
2. 对于那些超过了整个Region容量的超级大对象, 将会被存放在N个连续的Humongous Region之中

G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待

> 通过参数-XX:G1HeapRegionSize设定,取值范围为1MB~32MB,且应为2的N次幂

#### 为什么 G1 能够建立可预测的停顿时间模型?

1. 因为它将Region作为单次回收的最小单元,即每次收集到的内存空间都是Region大小的整数倍,这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集
2. G1收集器的停顿预测模型是以衰减均值(Decaying Average)为理论基础来实现的, 最近的平均状态

> G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小,价值即回收所获得的空间大小以及回收所需时间的经验值,然后在后台维护一个优先级列表,每次根据用户设定允许的收集停顿时间(使用参数-XX:MaxGCPauseMillis指定,默认值是200毫秒),优先处理回收价值收益最大的那些Region,这也就是“Garbage First”名字的由来, 保证了 g1 收集器能够在有限的时间获取尽可能高的收集效率

#### 跨代引用如何解决? 占用的空间更大了么?

每个Region都维护有自己的记忆集,这些记忆集会记录下别的Region 指向自己的指针,并标记这些指针分别在哪些卡页的范围之内.

卡表是“我指向谁”,这种结构还记录了“谁指向我”, 实现上更为复杂.同时由于Region数量比传统收集器的分代数量明显要多得多,因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。根据经验,**G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作**

#### 并发标记阶段如何保证收集线程与用户线程互不干扰地运行?

1. 原始快照算法(SATB) 保证了原有的对象图结构不被破坏
2. G1为每一个Region设计了两个名为TAMS(Top at Mark Start)的指针,把Region中的一部分空间划分出来用于并发回收过程中的新对象分配,并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的,即默认它们是存活的,不纳入回收范围(即新分配的对象不会被回收)

#### G1 也会产生 full gc 吗?

如果内存回收的速度赶不上内存分配的速度, G1收集器也要被迫冻结用户线程执行,导致Full GC而产生长时间“Stop The World”

#### G1 回收的四个步骤

1. 初始标记(initial mark), 标记GC Roots能直接关联到的对象, 并且修改 tams 的值保证并发标记过程中新对象能够正确分配. 需要 **stw**
2. 并发标记(concurrent mark) 从 GC Roots 做可达性分析, 扫描完成后还需重新处理 SATB 记录下的在并发时有引用变动的对象
3. 最终标记(final marking), **stw**, 处理并发标记阶段结束后仍遗留的少量 satb 记录,很快基本不影响
4. 筛选回收(Live Data Counting and Evacuation):负责更新Region的统计数据,对各个Region的回收价值和成本进行排序,根据用户所期望的停顿时间来制定回收计划,可以自由选择任意多个Region 构成回收集,然后把决定回收的那一部分Region的存活对象复制到空的Region中,再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动,是必须暂停用户线程,由多条收集器线程并行完成的 **stw**

除了并发标记阶段不需要 stw, 其他阶段都需要 stw. 不是单纯的追求低延迟,目标是尽量在延迟可控的情况下获得尽可能高的 throughput

### CMS VS G1 对比

G1 的优点:

1. 可以指定最大停顿时间,分 region 的内存布局,新算法的红利等等
2. 基于标记整理/压缩的算法, 减少了 full gc. 有利用程序长时间的运行
3. satb 算法减少了并发标记和重新标记阶段的消耗,避免了 CMS 那样在最终标记阶段停顿时间过长的缺点
4. 后续支持更好,未来的收集器

G1 的缺点:

1. region + 为了解决跨代引用问题, 导致卡表实现更为复杂, 占用内存更多. 并且因为不分老年代新生代, 新生代的卡表实现其实有点浪费内存
2. 为了实现 SATB 算法, 需要使用写前屏障来跟踪并发时的指针变化情况. 带来了更多的额外负担,消耗了更多的运算资源.

总结: 小内存应用还是 Parallel ParNew + CMS 更加合适. 而在大应用上, g1 能更好的发挥它的优势. G1 战未来! CMS 更适合 8GB 以下, G1 更适合大内存.
