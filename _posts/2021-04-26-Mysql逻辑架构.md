---
title: "Mysql逻辑架构"
last_modified_at: 2021-04-21T16:05:02-05:00
categories:
  - Blog
tags:
  - Mysql
# link: https://foresx.github.io/blog
header:
  overlay_image: /assets/images/banner.jpg
  overlay_filter: 0.5

---

## 学习 Mysql 的目的

### Mysql 逻辑架构分析

![Mysql logic](/assets/images/mysql-logic-structure.png)

Mysql 主要分为两层: server 层和存储引擎这两层.

1. Server 层包括,连接器,查询缓存,分析器,优化器,执行器以及所有的内置函数(如:日期,时间,数学,加密函数等),所有跨存储引擎的功能都在这一层实现,比如存储过程,触发器和视图等.
2. 存储引擎负责数据的存储和提取,提供读写接口.支持 InnoDb, MyISAM, Memory 等多个存储引擎.mysql 5.5.5 版本后,InnoDb为默认的存储引擎.(在 create table 中可以指定 engine = *来使用指定的存储引擎创建表)

#### 各个组件的作用

##### 连接器

负责跟客户端建立连接,获取权限,维持和管理连接.

```sh
mysql -h ip -P port -u user -p password
```

这里的 mysql 是客户端使用的连接工具,与 server 建立起 tcp 连接,然后验证身份.如果身份验证通过,那么**连接器**会根据权限表查出用户的权限并赋予,之后这个连接里面的权限判断逻辑,都依赖与此时读到的权限.

> tips: 这一点就说明,如果用户成功建立连接以后,你修改了这个用户的权限,已经存在的连接也不会受到影响了.

```sh
# 查看当前连接状况
show processlist
# command 列中为 Sleep 的代表出于空闲状态
# 如果连接太长时间没动静了,连接器会自动将连接断开.这个时间由参数wait_timeout控制,默认为 8h
# 如果基于断开的连接继续发送请求的话, 会收到一个错误提醒 Lost connection to MySQL server during query. 需要重连才能继续请求.
```

在数据库中连接分为长连接,短连接. 长连接指的是**连接成功后,如果客户端持续请求,则一直使用同一个连接.** 短连接指的是**每次执行完很少次的查询就会断开连接,下次查询再重新建立连接.**

两者主要的区别在于操作过程不同:
短连接的操作步骤是：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接
长连接的操作步骤是：建立连接——数据传输…（保持连接）…数据传输——关闭连接

> 所以我们会尽量使用长连接,减少连接的动作.但是如果全部使用长连接,对 mysql 的内存要求比较高,会导致 mysql 内存涨的很快.因为 mysql 在执行过程中临时使用的内存是管理在连接对象中的.所以这些资源只有在连接断开的时候才会被释放.如果长连接过多,资源比较吃紧,会导致内存不够,从而 OOM, mysql 异常重启.

**如何解决长连接过多导致内存不够,mysql 异常重启的问题呢?**

1. 定期断开长连接.(定期断开,或者程序里面判断一个占用内存的大查询后,断开连接,之后要查询再重连)
2. MySQL5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要做重连和重新的权限验证,会将连接回复到刚刚创建完的状态.

高版本中推荐使用第二种方式,低版本只能使用定期断开长连接.

> 1、会回滚所有活动事务，并重置自动提交模式；
> 2、会释放所有的锁表；
> 3、所有的临时表会被关闭并清除；
> 4、Session 系统变量会被重新初始化为相应的全局系统变量的值；
> 5、用户自定义变量会丢失；
> 6、会释放 Prepared statements；
> 7、HANDLER 变量会被关闭；
> 8、LAST_INSERT_ID() 函数的值会被重置为 0；
> 9、通过 GET_LOCK() 函数获得的锁会被释放；

###### 数据库连接池 - 目的都是为了减少建立连接所带来的损耗

数据库连接池，就是服务器应用建立多个连接到数据库，还没有用的连接就放到连接池上，要的时候就向连接池取，这样比没有连接时再建立新的连接（TCP 建立连接是需要时间的）时要快很多，从而提高传输效率。

如 Spring 框架中，它实现了一个持久连接池，允许其他程序、客户端来连接，这个连接池将被所有连接的客户端共享使用，连接池可以加速连接，也可以减少数据库连接，降低数据库服务器的负载。

##### 查询缓存

连接建立成功后,就到 select 语句了.这时就会到查询缓存这一步了.
根据 key: 语句, value: 返回结果, 根据 key 去查询内存缓存中是否还有这个结果,如果找到了就直接返回 value. 如果没找到,就会执行后面的分析,优化,执行的部分了,然后执行的结果会被写入查询缓存中.这里对 key 的判断是完全匹配,区分大小写,空格等,两个 sql 需要完全一致才能缓存命中.

> **但是大多数情况下,不建议使用查询缓存, 查询缓存弊大于利** 查询缓存的失效非常频繁,只要有对一个表有更新,这个表上所有的查询缓存都会被情况. 只适合偏静态的表,比如系统配置表,这个表上的查询才适合查询缓存.
> 按需使用mysql 查询缓存: query_cache_type 设置为 DEMAND. 这样默认的 select 语句不会走查询缓存. 而对于你需要使用查询缓存的语句,你需要使用 SQL_CACHE显示指定.

```sql
select SQL_CACHE * from T where ID = 10;
```

ps: 在 mysql8.0 版本后,直接删除了查询缓存这块功能,8.0 以后这个鸡肋彻底没了.

##### 分析器(解析器)

分析器是对你的sql 语句进行分析的模块.
词法分析(识别各个关键字以及参数) -> 语法分析(根据语法规则,判断你的 sql 是否满足 mysql 语法)

eg: 如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒

> 一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容.
> eg: 如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那 肯定是会报“不存在这个列”的错误: “Unknown column ‘k’ in ‘where clause’”. 这个问题就是由分析器检查出来的.

解析器的最终执行结果就是解析树，提供给优化器使用。

##### 优化器

优化器是为了保证在有多种选择的情况下,选择出一个比较好的方案.在表里面有多个索引的时候，决定使用哪个索引;或者在一个语句有多表关联(join)的时候，决定各个表的连接顺序.

```sql
select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
```

先选 t1,再选 t2,或者反过来都可以.但是不同的执行顺序,执行出来的效率会不同,优化器就是决定使用哪个方案的.

优化器的几个重要任务(尽可能地使用索引):
> 1、选择最合适的索引；
> 2、选择表扫还是走索引；
> 3、选择表关联顺序；
> 4、优化 where 子句；
> 5、排除管理中无用表；
> 6、决定 order by 和 group by 是否走索引；
> 7、尝试使用 inner join 替换 outer join；
> 8、简化子查询，决定结果缓存；
> 9、合并试图；

> 使用索引的目的,是为了排除不符合的数据行.

##### 执行器

```sql
select * from T where ID=10;
# ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```

在真正执行前,会进行一次权限判断,判断你对这个表 T 有无权限.如果有权限才会打开表继续执行.
打开表的时候执行器就会根据存储引擎的定义去使用引擎提供的接口.

比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的:

1. 调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则
将这行存在结果集中;
2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

对于有索引的表，执行的逻辑也差不多。第一次调用的是取满足条件的第一行这个接口，之后循环取满足条件的下一行这个接口，这些接口都是引擎中已经定义好的。
可以看出，是否有索引，执行效率区别还是很大的，**没有索引需要取出所有数据，一个个进行比较；而有索引则是直接取满足条件的数据**；

> 在数据的慢查询日志中可以看到rows_examined : 代表这个语句在执行过程中扫描了多少行. 这个值就是在执行器每次调用引擎获取数据行的时候累加的.
> 在优先情况下,引擎扫描行数和 rows_examined 不一致. 是因为执行器调用了一次,引擎扫描了多行.
